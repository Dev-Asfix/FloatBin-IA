<!DOCTYPE html>
<html lang="es">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>FlotaBin IA</title>
    <link rel="stylesheet" href="styles.css" />
    <link rel="icon" href="/public/images/Robot.png" type="image/x-icon" />
  </head>
  <body>
    <!--     AIzaSyDK7fN73zyVMYsj0g_ZP5HOKyOlZfTouxI -->
    <div class="container-principal">
      <div class="left-section">
        <!-- Contenido de la secci贸n izquierda -->
        <h2 id="h2e">FlotaBin IA</h2>
        <div class="content">
          <!-- Tacho a la izquierda -->
          <div class="tacho">
            <div id="nivel" class="nivel"></div>
          </div>

          <!-- Info a la derecha -->
          <div class="info">
            <p id="estado">Estado: --</p>
            <p id="distancia">Distancia: -- cm</p>
            <p id="fecha">Fecha y Hora: --</p>
            <p id="alerta" class="alerta"></p>
          </div>
        </div>

        <div class="audio-container" id="audioContainer">
          <div class="audio-icon"></div>
          <audio id="audioPlayer" controls></audio>
        </div>
      </div>

      <!-- Secci贸n Derecha -->
      <div class="right-section">
        <div class="guardar">
          <button
            id="guardadito"
            onclick="window.location.href='/clima-main/index.html'"
          >
            ML
          </button>

          <div id="recommendations">
            <div class="analysis">
              <h2>Recomendaciones</h2>
              <p id="mensajeRecomendacion">Esperando datos...</p>
            </div>
          </div>
          <div id="recommendations">
            <div class="analysis">
              <h2>Predicciones</h2>
              <p id="prediccionLlenado">Esperando datos...</p>
              <div id="waterEffect"></div>
              <div class="sparks" id="sparksEffect"></div>
            </div>
          </div>
        </div>
        <div class="analysis">
          <p id="averageFillTime">Promedio: -- segundos</p>
        </div>

        <!-- Tabla -->
        <div class="table-section">
          <h2>Duraci贸n de los estados</h2>
          <div class="tablita">
            <table>
              <thead>
                <tr>
                  <th>Estado</th>
                  <th>Fecha</th>
                  <th>Duraci贸n</th>
                </tr>
              </thead>
              <tbody id="estadoTable"></tbody>
            </table>
          </div>
        </div>
      </div>
    </div>

    <script>
      const ws = new WebSocket("ws://192.168.18.20:3000");
      // Conexi贸n WebSocket al servidor
      const socket = new WebSocket("ws://192.168.18.20:3000");
      let estadoActual = "";
      let inicioEstado;
      let tiemposEstados = [];
      let audioIndex = 0;
      let audioPlaying = false;

      const audios = [
        "audios/audio1.mp3",
        "audios/audio2.mp3",
        "audios/audio3.mp3",
        "audios/audio4.mp3",
        "audios/audio5.mp3",
        "audios/audio6.mp3",
        "audios/audio7.mp3",
        "audios/audio8.mp3",
        "audios/audio9.mp3",
        "audios/audio10.mp3",
        "audios/audio11.mp3",
        "audios/audio12.mp3",
        "audios/audio13.mp3",
        "audios/audio14.mp3",
        "audios/audio15.mp3",
        "audios/audio16.mp3",
        "audios/audio17.mp3",
        "audios/audio18.mp3",
        "audios/audio19.mp3",
        "audios/audio20.mp3",
        "audios/audio21.mp3",
        "audios/audio22.mp3",
        "audios/audio23.mp3",
        "audios/audio24.mp3",
        "audios/audio25.mp3",
        "audios/audio26.mp3",
        "audios/audio27.mp3",
        "audios/audio28.mp3",
      ];

      // Evento cuando se recibe un mensaje del WebSocket
      socket.onmessage = function (event) {
        const data = JSON.parse(event.data);

        const prediccionElement = document.getElementById("prediccionLlenado");
        const waterEffect = document.getElementById("waterEffect");
        const sparksEffect = document.getElementById("sparksEffect");

        // Si se recibe una predicci贸n de tiempo de llenado, actualizar el texto y detener animaci贸n
        if (data.predictedFillTime) {
          applyNoBackgroundStyle();
          const predictedTimeSeconds = (data.predictedFillTime / 1000).toFixed(
            2
          ); // Convertir a segundos
          prediccionElement.textContent = `Tiempo estimado para llenarse: ${predictedTimeSeconds} segundos`;
          waterEffect.classList.remove("filling"); // Detener animaci贸n de agua
          sparksEffect.innerHTML = ""; // Eliminar chispas
        } else {
          applyBackgroundStyle();
          prediccionElement.textContent = `Alimentando redes neuronales...`;
          waterEffect.classList.add("filling"); // Activar animaci贸n de agua
          generateSparks(); // Generar chispas
        }
      };

      const prediccionElement = document.getElementById("prediccionLlenado");
      // Funci贸n para aplicar el estilo con fondo
      function applyBackgroundStyle() {
        prediccionElement.classList.add("with-background");
        prediccionElement.classList.remove("no-background");
        prediccionElement.classList.add("flickering"); // Activar animaci贸n de parpadeo
      }

      // Funci贸n para aplicar el estilo sin fondo
      function applyNoBackgroundStyle() {
        prediccionElement.classList.add("no-background");
        prediccionElement.classList.remove("with-background");
        prediccionElement.classList.remove("flickering"); // Desactivar animaci贸n de parpadeo
      }

      // Funci贸n para generar chispas
      function generateSparks() {
        const sparksEffect = document.getElementById("sparksEffect");
        sparksEffect.innerHTML = ""; // Limpiar chispas existentes
        for (let i = 0; i < 100; i++) {
          const spark = document.createElement("div");
          spark.classList.add("spark");
          const x = Math.random() * 100;
          const y = Math.random() * 100;
          const animationDelay = Math.random() * 2;
          const size = Math.random() * 5 + 2;
          spark.style.left = `${x}%`;
          spark.style.top = `${y}%`;
          spark.style.width = `${size}px`;
          spark.style.height = `${size}px`;
          spark.style.animationDelay = `-${animationDelay}s`;
          sparksEffect.appendChild(spark);
        }
      }

      // Evento para manejar errores en la conexi贸n
      socket.onerror = function (error) {
        console.error("WebSocket Error: ", error);
      };

      // Evento cuando el WebSocket se cierra
      socket.onclose = function () {
        console.log("Conexi贸n WebSocket cerrada");
      };

      function activateStyles() {
        element.style.color = "#00ffcc";
        element.style.textShadow = "0px 0px 10px #00ffcc";
        element.style.background = "rgba(0, 255, 255, 0.2)";
      }

      // Desactivar estilos
      function deactivateStyles() {
        element.style.color = "";
        element.style.textShadow = "";
        element.style.background = "";
      }

      ws.onmessage = (event) => {
        const data = JSON.parse(event.data);
        document.getElementById("estado").innerText = `Estado: ${data.estado}`;
        document.getElementById(
          "distancia"
        ).innerText = `Distancia: ${data.distancia} cm`;
        document.getElementById(
          "fecha"
        ).innerText = `Fecha y Hora: ${data.timestamp}`;
        document.getElementById("averageFillTime").innerText = `Promedio: ${
          data.averageFillTime || "--"
        } segundos`;

        if (data.alert) {
          document.getElementById("alerta").innerText = data.alert;
        }

        actualizarTacho(data.estado);
        registrarEstado(data.estado, data.timestamp);
        calcularPromedioLlenado();

        mostrarRecomendacion(data.averageFillTime);

        // Reproducir o detener audio si el estado es "Lleno"
        if (data.estado === "Lleno" && !audioPlaying) {
          reproducirAudiosSecuenciales();
        } else if (data.estado !== "Lleno" && audioPlaying) {
          detenerAudio();
        }
      };

      function actualizarTacho(estado) {
        const nivel = document.getElementById("nivel");
        let porcentaje = 0;
        switch (estado) {
          case "Vacio":
            porcentaje = 0;
            break;
          case "Bajo":
            porcentaje = 25;
            break;
          case "Medio":
            porcentaje = 50;
            break;
          case "Alto":
            porcentaje = 75;
            break;
          case "Lleno":
            porcentaje = 100;
            break;
        }
        nivel.style.height = `${porcentaje}%`;
      }

      function registrarEstado(estado, timestamp) {
        if (estado !== estadoActual) {
          const finEstado = new Date();
          if (estadoActual !== "") {
            const duracion = (finEstado - inicioEstado) / 1000;
            const row = `<tr><td>${estadoActual}</td><td>${timestamp}</td><td>${duracion.toFixed(
              2
            )} s</td></tr>`;
            document.getElementById("estadoTable").innerHTML += row;
            tiemposEstados.push({ estado: estadoActual, duracion: duracion });
          }
          estadoActual = estado;
          inicioEstado = new Date();
        }
      }

      function calcularPromedioLlenado() {
        if (tiemposEstados.length === 0) return;

        const duraciones = tiemposEstados
          .filter((te) => te.estado !== "Vacio" && te.estado !== "Lleno")
          .map((te) => te.duracion);
        if (duraciones.length === 0) return;

        const promedio =
          duraciones.reduce((a, b) => a + b, 0) / duraciones.length;
        document.getElementById(
          "averageFillTime"
        ).innerText = `Promedio: ${promedio.toFixed(2)} segundos`;
      }

      function calcularTiempoLlenado(distancia) {
        const umbral = 3; // Distancia m铆nima para considerarlo lleno
        const tasaCambio = 5; // Ejemplo de tasa de cambio de nivel por segundo
        if (distancia < umbral) return "Inminente"; // Relleno en curso
        return ((distancia - umbral) / tasaCambio).toFixed(2);
      }

      function mostrarRecomendacion(promedio) {
        const promedioNum = parseFloat(promedio);
        let mensaje = "";

        if (!isNaN(promedioNum)) {
          if (promedioNum < 10) {
            mensaje = getRandomRecommendation([
              "El tiempo de llenado es moderado. Ajusta la planificaci贸n si es necesario.",
              "El tiempo de llenado es aceptable. Considera un monitoreo peri贸dico.",
              "El llenado es estable. Mant茅n el sistema bajo observaci贸n.",
              "El tacho se est谩 llenando r谩pidamente. Planifica vaciados frecuentes.",
              "El tiempo de llenado es corto. Vig铆lalo de cerca.",
              "El tacho se llena lentamente. Revisa que todo funcione bien.",
              "El llenado es prolongado. Considera revisar el sistema.",
              "El tacho se llena en poco tiempo. Ajusta los tiempos de vigilancia.",
              "El llenado parece m谩s lento de lo normal. Revisa el proceso.",
              "El llenado es estable. Mant茅n una observaci贸n peri贸dica.",
            ]);
          } else if (promedioNum < 20) {
            mensaje = getRandomRecommendation([
              "El tiempo de llenado es moderado. Ajusta la planificaci贸n si es necesario.",
              "El tiempo de llenado es aceptable. Considera un monitoreo peri贸dico.",
              "El llenado es estable. Mant茅n el sistema bajo observaci贸n.",
              "El tacho se est谩 llenando r谩pidamente. Planifica vaciados frecuentes.",
              "El tiempo de llenado es corto. Vig铆lalo de cerca.",
              "El tacho se llena lentamente. Revisa que todo funcione bien.",
              "El llenado es prolongado. Considera revisar el sistema.",
              "El tacho se llena en poco tiempo. Ajusta los tiempos de vigilancia.",
              "El llenado parece m谩s lento de lo normal. Revisa el proceso.",
              "El llenado es estable. Mant茅n una observaci贸n peri贸dica.",
            ]);
          } else {
            mensaje = getRandomRecommendation([
              "El tiempo de llenado es moderado. Ajusta la planificaci贸n si es necesario.",
              "El tiempo de llenado es aceptable. Considera un monitoreo peri贸dico.",
              "El llenado es estable. Mant茅n el sistema bajo observaci贸n.",
              "El tacho se est谩 llenando r谩pidamente. Planifica vaciados frecuentes.",
              "El tiempo de llenado es corto. Vig铆lalo de cerca.",
              "El tacho se llena lentamente. Revisa que todo funcione bien.",
              "El llenado es prolongado. Considera revisar el sistema.",
              "El tacho se llena en poco tiempo. Ajusta los tiempos de vigilancia.",
              "El llenado parece m谩s lento de lo normal. Revisa el proceso.",
              "El llenado es estable. Mant茅n una observaci贸n peri贸dica.",
            ]);
          }
        } else {
          mensaje =
            "No hay datos suficientes para proporcionar una recomendaci贸n.";
        }

        document.getElementById("mensajeRecomendacion").innerText = mensaje;
      }

      function getRandomRecommendation(recommendations) {
        const index = Math.floor(Math.random() * recommendations.length);
        return recommendations[index];
      }

      // Funci贸n para reproducir audios secuenciales mientras el estado es "Lleno"

      function reproducirAudiosSecuenciales() {
        const audioPlayer = document.getElementById("audioPlayer");
        const audioContainer = document.getElementById("audioContainer");

        // Solo reproducir el audio si no est谩 ya reproduci茅ndose
        if (!audioPlaying) {
          audioPlaying = true;

          // Seleccionar un audio aleatorio al inicio
          audioIndex = Math.floor(Math.random() * audios.length); // Aleatorio al iniciar

          audioPlayer.src = audios[audioIndex];
          audioPlayer.play();
          audioContainer.classList.add("playing");

          audioPlayer.onended = () => {
            // Cuando termina el audio, verificar si el estado sigue siendo 'Lleno'
            if (estadoActual === "Lleno") {
              // Seleccionar otro audio aleatorio
              audioIndex = (audioIndex + 1) % audios.length; // Aleatorio cada vez

              audioPlayer.src = audios[audioIndex];
              audioPlayer.play();
            } else {
              detenerAudio(); // Detener si el estado cambia
            }
          };

          audioPlayer.onerror = () => {
            console.error("Error al reproducir el audio.");
            detenerAudio();
          };
        }
      }

      // Funci贸n para detener el audio si el estado cambia
      function detenerAudio() {
        const audioPlayer = document.getElementById("audioPlayer");
        const audioContainer = document.getElementById("audioContainer");
        audioPlayer.pause();
        audioPlayer.currentTime = 0; // Reiniciar el tiempo del audio
        audioPlaying = false;
        audioContainer.classList.remove("playing");
        audioContainer.classList.add("stopped");
      }

      // Funci贸n que verifica el estado del sensor
      function verificarEstadoDelSensor() {
        if (sensorDetectaLleno()) {
          if (estadoActual !== "Lleno") {
            estadoActual = "Lleno";
            reproducirAudiosSecuenciales(); // Reproduce el audio solo cuando cambia a "Lleno"
          }
        } else {
          if (estadoActual === "Lleno") {
            estadoActual = "Vacio"; // O cualquier otro estado que definas
            detenerAudio(); // Detener el audio si ya no est谩 "Lleno"
          }
        }
      }

      // Simular funci贸n de detecci贸n del sensor
      function sensorDetectaLleno() {
        // Aqu铆 va tu l贸gica para detectar si el tacho est谩 lleno
        // Deber铆as retornar true si el sensor detecta que est谩 en el rango de lleno
        return Math.random() > 0.5; // Simulaci贸n (50% de probabilidad de estar lleno)
      }

      const image = document.querySelector(".audio-icon"); // Selecciona el 铆cono del audio

      let angleX = 0;
      let angleY = 0;
      let directionX = 1; // Direcci贸n de rotaci贸n en X
      let directionY = 1; // Direcci贸n de rotaci贸n en Y

      // Animaci贸n autom谩tica
      setInterval(() => {
        // Verifica si el contenedor del 铆cono tiene la clase "playing"
        const isPlaying = image
          .closest(".audio-container")
          ?.classList.contains("playing");

        // Ajusta los l铆mites de rotaci贸n dependiendo de si est谩 en "playing" o no
        if (isPlaying) {
          // L贸gica cuando est谩 en estado "playing"
          angleX += directionX * 0.5; // Rotaci贸n m谩s suave
          angleY += directionY * 1.5;

          // Limita la rotaci贸n en menor rango cuando est谩 en "playing"
          if (angleX > 15 || angleX < -10) {
            directionX *= -1; // Cambia de direcci贸n en X
          }
          if (angleY > 20 || angleY < -20) {
            directionY *= -1; // Cambia de direcci贸n en Y
          }
        } else {
          // L贸gica cuando NO est谩 en estado "playing"
          angleX += directionX; // Mantener una rotaci贸n m谩s sutil
          angleY += directionY;

          // Limita la rotaci贸n en mayor rango
          if (angleX > 35 || angleX < -10) {
            directionX *= -1; // Cambia de direcci贸n en X
          }
          if (angleY > 30 || angleY < -30) {
            directionY *= -1; // Cambia de direcci贸n en Y
          }
        }

        // Aplica la rotaci贸n a la imagen
        image.style.transform = `rotateX(${angleX}deg) rotateY(${angleY}deg)`;
      }, 100); // Velocidad de animaci贸n (ajustado a 100 ms para mayor fluidez)
    </script>
  </body>
</html>
